## Production Blockchain Verification Strategy

For production with 6000+ blocks, implement these verification methods:

### 1. Sample-Based Verification (Quick)
```python
def verify_block_sample(self, sample_rate=0.01):
    """Verify a random sample of blocks (1% by default)"""
    import random
    
    all_blocks = list(range(len(self.chains['B']._hash_index)))
    sample_size = max(10, int(len(all_blocks) * sample_rate))
    sample_indices = random.sample(all_blocks, min(sample_size, len(all_blocks)))
    
    for idx in sample_indices:
        block = self.chains['B'].storage.get_block_by_index(idx)
        if block:
            # Verify hash
            computed_hash = block.compute_hash()
            # Verify payload hash
            payload_hash = hashlib.sha256(block.payload).hexdigest()
            if payload_hash != block.header.payload_hash:
                return False
    return True
```

### 2. Background Verification (Non-blocking)
```python
async def verify_in_background(self):
    """Run full verification in background thread"""
    def verify_worker():
        logger.info("Starting background verification...")
        result = self.chains['B'].verify_chain()
        if not result:
            logger.error("Background verification failed!")
        else:
            logger.info("âœ… Background verification complete")
    
    import threading
    thread = threading.Thread(target=verify_worker)
    thread.daemon = True
    thread.start()
```

### 3. Merkle Tree Verification (Most Efficient)
```python
def verify_merkle_root(self):
    """Verify chain using merkle root (requires storing merkle trees)"""
    # This would require implementing merkle trees in the blockchain
    # Each block stores merkle root of previous N blocks
    # Only need to verify latest merkle root + recent blocks
    pass
```

### 4. Incremental Verification (Best for GPU nodes)
```python
def verify_new_blocks_only(self, last_verified_index):
    """Only verify blocks added since last verification"""
    current_count = len(self.chains['B']._hash_index)
    
    for idx in range(last_verified_index + 1, current_count):
        block = self.chains['B'].storage.get_block_by_index(idx)
        if not block:
            return False
        # Verify this block
        if not self.verify_single_block(block):
            return False
    
    return True
```

### Recommended Approach for GPU Nodes:
1. **On startup**: Skip full verification, use index count
2. **After upload**: Verify only the newly uploaded blocks
3. **Periodically**: Run sample verification in background
4. **Before inference**: Verify specific expert blocks being used