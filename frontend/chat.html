<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat - Blyan</title>
    <link rel="stylesheet" href="components.css">
    <link rel="stylesheet" href="style.css">
    <script src="language.js"></script>
    <style>
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            height: calc(100vh - 120px);
            display: flex;
            flex-direction: column;
        }
        /* Layout with sidebar */
        .chat-layout {
            display: flex;
            gap: 16px;
            max-width: 1200px;
            margin: 0 auto;
            padding: 16px;
            min-height: calc(100vh - 100px);
        }
        .chat-sidebar {
            width: 280px;
            background: #0f172a;
            color: #e2e8f0;
            border-radius: 12px;
            padding: 12px;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .new-chat-btn {
            background: #22c55e;
            color: #0b1220;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            cursor: pointer;
            font-weight: 600;
        }
        .session-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex: 1;
        }
        .session-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            padding: 10px 12px;
            margin-bottom: 6px;
            background: #111827;
            border: 1px solid #1f2937;
            border-radius: 8px;
            cursor: pointer;
        }
        .session-item.active {
            background: #1f2937;
            border-color: #334155;
        }
        .session-title {
            color: #e5e7eb;
            font-size: 14px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        .session-actions button {
            background: transparent;
            color: #9ca3af;
            border: none;
            cursor: pointer;
        }
        .chat-header {
            background: white;
            padding: 20px;
            border-radius: 12px 12px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            text-align: center;
        }
        .chat-window {
            flex: 1;
            background: white;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        .chat-input-area {
            background: white;
            padding: 20px;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
        }
        
        .message {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 12px;
            max-width: 80%;
            word-wrap: break-word;
        }
        .message.user {
            background: var(--primary-color);
            color: white;
            margin-left: auto;
            text-align: right;
        }
        .message.ai {
            background: #f8f9fa;
            color: var(--text-color);
            border: 1px solid #e9ecef;
        }
        .message-sender {
            font-weight: bold;
            margin-bottom: 5px;
            font-size: 0.9em;
        }
        .chat-form {
            display: flex;
            gap: 10px;
        }
        .chat-input {
            flex: 1;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 16px;
            outline: none;
        }
        .chat-input:focus {
            border-color: var(--primary-color);
        }
        .send-button {
            padding: 15px 25px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.3s ease;
        }
        .send-button:hover:not(:disabled) {
            background: var(--primary-hover);
        }
        .send-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .typing-indicator {
            display: none;
            color: var(--text-muted);
            font-style: italic;
            padding: 10px 0;
        }
        
        /* Streaming UI styles */
        .streaming-metrics {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            display: none;
        }
        .streaming-metrics.active {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .metric {
            text-align: center;
        }
        .metric-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-color);
        }
        .metric-label {
            font-size: 0.75rem;
            color: #6b7280;
            text-transform: uppercase;
        }
        .cancel-stream-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            cursor: pointer;
            display: none;
            margin-left: 10px;
        }
        .cancel-stream-btn:hover {
            background: #dc2626;
        }
        .usage-indicator {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
            font-size: 0.9em;
        }
        .usage-indicator.free-tier {
            border-color: #10b981;
            background: #ecfdf5;
        }
        .usage-indicator.paid-tier {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        .usage-indicator.low-balance {
            border-color: #f59e0b;
            background: #fffbeb;
        }
        .usage-bar {
            background: #e5e7eb;
            height: 4px;
            border-radius: 2px;
            overflow: hidden;
            margin: 8px 0 4px 0;
        }
        .usage-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #059669);
            transition: width 0.3s ease;
        }
        .usage-fill.low {
            background: linear-gradient(90deg, #f59e0b, #d97706);
        }
        .usage-fill.critical {
            background: linear-gradient(90deg, #ef4444, #dc2626);
        }
    </style>
</head>
<body>
    <div id="header-container"></div>

    <div class="chat-layout">
        <aside class="chat-sidebar">
            <div class="sidebar-header">
                <div style="font-weight:700;">üí¨ <span data-i18n="chats">Chats</span></div>
                <button class="new-chat-btn" id="new-chat-btn" data-i18n="newChat">New</button>
            </div>
            <ul class="session-list" id="session-list"></ul>
        </aside>

        <div class="chat-container" style="flex:1;">
            <div class="chat-header">
                <h1>ü§ñ <span data-i18n="aiChat">AI Chat</span></h1>
                <p data-i18n="chatWithDistributed">Chat with our decentralized AI network</p>
            </div>
            
            <div class="chat-window" id="chat-window">
                <div class="message ai">
                    <div class="message-sender" data-i18n="aiAssistant">AI Assistant</div>
                    <div data-i18n="aiWelcomeMessage">Hello! I'm powered by the Blyan decentralized network. Ask me anything!</div>
                </div>
            </div>
            
            <div class="typing-indicator" id="typing-indicator">
                <span data-i18n="aiThinking">AI is thinking...</span>
                <button id="cancelStreamBtn" class="cancel-stream-btn" onclick="cancelStream()">Cancel</button>
            </div>
            
            <!-- Usage Indicator -->
            <div id="usageIndicator" class="usage-indicator" style="display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <span id="usageText">Checking usage...</span>
                    <span id="usageCount" style="font-weight: 600;"></span>
                </div>
                <div class="usage-bar">
                    <div id="usageFill" class="usage-fill" style="width: 100%;"></div>
                </div>
                <div id="usageDetail" style="font-size: 0.8em; color: #6b7280; margin-top: 4px;"></div>
            </div>
            
            <div class="streaming-metrics" id="streamingMetrics">
                <div class="metric">
                    <div class="metric-value" id="tokenCount">0</div>
                    <div class="metric-label">Tokens</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="tokenSpeed">0</div>
                    <div class="metric-label">Tokens/sec</div>
                </div>
                <div class="metric">
                    <div class="metric-value" id="currentCost">0.000</div>
                    <div class="metric-label">BLY Cost</div>
                </div>
                <div class="metric">
                    <input type="range" id="maxTokens" min="50" max="500" value="200" 
                           style="width: 60px; margin: 0;" onchange="updateTokenDisplay()">
                    <div class="metric-label">Max Tokens</div>
                    <div id="tokenDisplay" style="font-size: 0.8em; color: #6b7280;">200</div>
                </div>
            </div>
            
            <div class="chat-input-area">
                <form class="chat-form" id="chat-form">
                    <input 
                        type="text" 
                        id="chat-input" 
                        class="chat-input" 
                        placeholder="Type your message..."
                        data-i18n-placeholder="typeYourMessage"
                        autocomplete="off"
                        required
                    >
                    <button type="submit" class="send-button" id="send-button" data-i18n="send">Send</button>
                </form>
            </div>
        </div>
    </div>


    <script src="config.js"></script>
    <script src="common-header.js"></script>
    <script src="wallet.js"></script>
    <script>
        // Global session persistence
        const SESSIONS_KEY = 'blyan-chat-sessions-v1';
        const SESSION_PREFIX = 'blyan-chat-session-';
        let currentSessionId = null;
        let chatHistory = [];
        
        // Streaming variables
        let eventSource = null;
        let currentStreamId = null;
        let currentMessageElement = null;
        let accumulatedTokens = '';
        let streamErrorCount = 0;
        
        document.addEventListener('DOMContentLoaded', () => {
            // Create header
            document.getElementById('header-container').innerHTML = createAIBlockHeader('chat');
            
            const chatForm = document.getElementById('chat-form');
            const chatInput = document.getElementById('chat-input');
            const chatWindow = document.getElementById('chat-window');
            const sendButton = document.getElementById('send-button');
            const typingIndicator = document.getElementById('typing-indicator');
            
            // Session UI
            const sessionListEl = document.getElementById('session-list');
            const newChatBtn = document.getElementById('new-chat-btn');
            newChatBtn.addEventListener('click', () => createNewSession());
            
            // Load user usage information
            loadUserUsage();
            
            // Update header usage indicator
            updateHeaderUsage();

            // Load or create initial session
            ensureDefaultSession();
            renderSessionList();
            loadSession(currentSessionId);

            chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const message = chatInput.value.trim();
                if (!message) return;

                // Add user message and start streaming immediately
                addMessage('user', message);
                chatInput.value = '';
                await startStreaming(message);
            });

            function addMessage(sender, content, saveToHistory = true) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}`;
                
                const senderDiv = document.createElement('div');
                senderDiv.className = 'message-sender';
                senderDiv.textContent = sender === 'user' ? 'You' : 'AI Assistant';
                
                const contentDiv = document.createElement('div');
                contentDiv.textContent = content;
                
                messageDiv.appendChild(senderDiv);
                messageDiv.appendChild(contentDiv);
                
                chatWindow.appendChild(messageDiv);
                chatWindow.scrollTop = chatWindow.scrollHeight;
                
                // Save to persistent history
                if (saveToHistory) {
                    const message = { sender, content, timestamp: Date.now() };
                    chatHistory.push(message);
                    saveSession(currentSessionId, chatHistory);
                    // If first user message, set session title
                    const sessions = getSessions();
                    const idx = sessions.findIndex(s => s.id === currentSessionId);
                    if (idx >= 0 && !sessions[idx].title) {
                        sessions[idx].title = content.slice(0, 40);
                        sessions[idx].updatedAt = Date.now();
                        saveSessions(sessions);
                        renderSessionList();
                    }
                }
            }

            // Expose for global helpers defined outside this closure
            window.addChatMessage = addMessage;
            window.showTypingIndicator = showTyping;
            
            function ensureDefaultSession() {
                const sessions = getSessions();
                if (!sessions.length) {
                    const id = genId();
                    const newSession = { id, title: '', createdAt: Date.now(), updatedAt: Date.now() };
                    saveSessions([newSession]);
                    saveSession(id, []);
                    currentSessionId = id;
                } else {
                    currentSessionId = sessions[0].id;
                }
            }

            function genId() {
                return 's_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
            }

            function getSessions() {
                try { return JSON.parse(localStorage.getItem(SESSIONS_KEY) || '[]'); } catch { return []; }
            }
            function saveSessions(sessions) {
                localStorage.setItem(SESSIONS_KEY, JSON.stringify(sessions));
            }
            function loadSession(id) {
                try {
                    const saved = localStorage.getItem(SESSION_PREFIX + id);
                    chatHistory = saved ? JSON.parse(saved) : [];
                    // Clear window except welcome
                    const existing = chatWindow.querySelectorAll('.message');
                    existing.forEach((msg, index) => { if (index > 0) msg.remove(); });
                    chatHistory.forEach(m => addMessage(m.sender, m.content, false));
                    currentSessionId = id;
                    highlightActiveSession();
                } catch (e) { console.error('loadSession failed', e); }
            }
            function saveSession(id, messages) {
                try {
                    const trimmed = messages.length > 200 ? messages.slice(-200) : messages;
                    localStorage.setItem(SESSION_PREFIX + id, JSON.stringify(trimmed));
                    const sessions = getSessions();
                    const idx = sessions.findIndex(s => s.id === id);
                    if (idx >= 0) { sessions[idx].updatedAt = Date.now(); saveSessions(sessions); }
                } catch (e) { console.error('saveSession failed', e); }
            }
            function renderSessionList() {
                const sessions = getSessions().sort((a,b) => (b.updatedAt||0)-(a.updatedAt||0));
                sessionListEl.innerHTML = '';
                sessions.forEach(s => {
                    const li = document.createElement('li');
                    li.className = 'session-item' + (s.id === currentSessionId ? ' active' : '');
                    li.innerHTML = `
                        <div class="session-title" title="${(s.title||'New chat')}">${(s.title||'New chat')}</div>
                        <div class="session-actions">
                            <button title="Rename" data-act="rename">‚úèÔ∏è</button>
                            <button title="Delete" data-act="delete">üóëÔ∏è</button>
                        </div>`;
                    li.addEventListener('click', (e) => {
                        const act = (e.target && e.target.dataset && e.target.dataset.act) || '';
                        if (act === 'delete') { e.stopPropagation(); return deleteSession(s.id); }
                        if (act === 'rename') { e.stopPropagation(); return renameSession(s.id); }
                        loadSession(s.id);
                    });
                    sessionListEl.appendChild(li);
                });
            }
            function highlightActiveSession() {
                const nodes = sessionListEl.querySelectorAll('.session-item');
                nodes.forEach(n => n.classList.remove('active'));
                const sessions = getSessions();
                const idx = sessions.findIndex(s => s.id === currentSessionId);
                if (idx >= 0 && sessionListEl.children[idx]) sessionListEl.children[idx].classList.add('active');
            }
            function createNewSession() {
                const id = genId();
                const sessions = [{ id, title: '', createdAt: Date.now(), updatedAt: Date.now() }, ...getSessions()];
                saveSessions(sessions);
                saveSession(id, []);
                currentSessionId = id;
                renderSessionList();
                loadSession(id);
            }
            function deleteSession(id) {
                if (!confirm('Delete this chat?')) return;
                const sessions = getSessions().filter(s => s.id !== id);
                saveSessions(sessions);
                localStorage.removeItem(SESSION_PREFIX + id);
                if (currentSessionId === id) {
                    if (sessions.length) { currentSessionId = sessions[0].id; } else { ensureDefaultSession(); }
                    loadSession(currentSessionId);
                }
                renderSessionList();
            }
            function renameSession(id) {
                const sessions = getSessions();
                const s = sessions.find(x => x.id === id);
                const title = prompt('Rename chat', s && s.title ? s.title : '');
                if (title !== null) {
                    s.title = title.trim();
                    s.updatedAt = Date.now();
                    saveSessions(sessions);
                    renderSessionList();
                }
            }

            function showTyping(show) {
                typingIndicator.style.display = show ? 'block' : 'none';
                sendButton.disabled = show;
                
                // Show/hide cancel button during streaming
                const cancelBtn = document.getElementById('cancelStreamBtn');
                if (cancelBtn) {
                    cancelBtn.style.display = show ? 'inline-block' : 'none';
                }
                
                if (show) {
                    chatWindow.scrollTop = chatWindow.scrollHeight;
                }
            }

            // Auto-focus input
            chatInput.focus();
        });

        // Streaming chat functions
        async function startStreaming(message) {
            showTyping(true);
            
            // Show streaming metrics panel
            const metricsPanel = document.getElementById('streamingMetrics');
            metricsPanel.classList.add('active');
            
            // Create AI message element for streaming
            currentMessageElement = addStreamingMessage('', 'ai');
            accumulatedTokens = '';
            
            try {
                const maxTokens = document.getElementById('maxTokens')?.value || 200;
                const params = new URLSearchParams({
                    prompt: message,
                    max_new_tokens: maxTokens
                });
                
                // Add user headers for authentication
                const headers = getUserHeaders();
                const headerParams = new URLSearchParams();
                Object.entries(headers).forEach(([key, value]) => {
                    headerParams.append(key, value);
                });
                
                eventSource = new EventSource(`${API_CONFIG.baseURL}/chat/stream?${params}&${headerParams}`);
                
                eventSource.addEventListener('stream_start', (event) => {
                    const data = JSON.parse(event.data);
                    currentStreamId = data.stream_id;
                });
                
                eventSource.addEventListener('token', (event) => {
                    const data = JSON.parse(event.data);
                    handleStreamToken(data);
                });
                
                eventSource.addEventListener('stream_end', (event) => {
                    const data = JSON.parse(event.data);
                    handleStreamEnd(data);
                });
                
                eventSource.addEventListener('error', (event) => {
                    handleStreamError(event);
                });
                
                // Handle EventSource connection errors (CORS, network, etc)
                eventSource.onerror = (event) => {
                    console.error('EventSource connection error:', event);
                    streamErrorCount++;
                    
                    if (streamErrorCount <= 2) {
                        // Retry streaming up to 2 times
                        setTimeout(() => {
                            cleanupStream();
                            startStreaming(message);
                        }, 1000);
                    } else {
                        // After 2 failures, show error and reset
                        handleStreamError({ error: 'Connection failed after retries' });
                        streamErrorCount = 0;
                    }
                };
                
            } catch (error) {
                console.error('Streaming error:', error);
                if (currentMessageElement) {
                    currentMessageElement.textContent = 'Error: Failed to start streaming';
                }
                cleanupStream();
            }
        }

        function getUserAddress() {
            return localStorage.getItem('userAddress') || '0x' + Math.random().toString(16).substr(2, 40);
        }

        function getUserHeaders() {
            const userAddress = getUserAddress();
            const headers = { 'X-User-Address': userAddress };
            // Optional API key for protected endpoints (stored once in localStorage)
            const apiKey = localStorage.getItem('apiKey');
            if (apiKey) headers['X-API-Key'] = apiKey;
            return headers;
        }

        function showError(message) {
            // Add error message directly to chat
            addMessage('ai', `‚ùå ${message}`);
        }

        function addStreamingMessage(text, sender) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${sender} streaming`;
            
            const senderDiv = document.createElement('div');
            senderDiv.className = 'message-sender';
            senderDiv.textContent = sender === 'user' ? 'You' : 'AI Assistant';
            
            const contentDiv = document.createElement('div');
            contentDiv.textContent = text;
            
            messageDiv.appendChild(senderDiv);
            messageDiv.appendChild(contentDiv);
            
            const chatWindow = document.getElementById('chat-window');
            chatWindow.appendChild(messageDiv);
            chatWindow.scrollTop = chatWindow.scrollHeight;
            
            return contentDiv;
        }
        
        function handleStreamToken(data) {
            if (data.token && currentMessageElement) {
                accumulatedTokens += data.token;
                currentMessageElement.textContent = accumulatedTokens;
                
                // Update metrics
                updateStreamingMetrics(
                    data.token_number || 0,
                    data.tokens_per_second || 0,
                    data.cumulative_cost || 0
                );
            }
        }
        
        function handleStreamEnd(data) {
            if (currentMessageElement) {
                currentMessageElement.parentElement.classList.remove('streaming');
                
                // Save to history
                const message = { sender: 'ai', content: accumulatedTokens, timestamp: Date.now() };
                chatHistory.push(message);
                saveSession(currentSessionId, chatHistory);
            }
            
            // Update usage after chat completion
            updateUsageAfterChat(data.cumulative_cost || 0);
            
            cleanupStream();
        }
        
        function handleStreamError(error) {
            console.error('Stream error:', error);
            if (currentMessageElement) {
                currentMessageElement.textContent = 'Error: Failed to generate response';
                currentMessageElement.parentElement.classList.remove('streaming');
            }
            cleanupStream();
        }
        
        function cleanupStream() {
            showTyping(false);
            currentStreamId = null;
            currentMessageElement = null;
            accumulatedTokens = '';
            
            // Hide streaming metrics panel after delay
            setTimeout(() => {
                const metricsPanel = document.getElementById('streamingMetrics');
                metricsPanel.classList.remove('active');
                // Reset metrics
                updateStreamingMetrics(0, 0, 0);
            }, 2000);
            
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
        }
        
        function updateStreamingMetrics(tokens, speed, cost) {
            document.getElementById('tokenCount').textContent = tokens || 0;
            document.getElementById('tokenSpeed').textContent = speed ? speed.toFixed(1) : '0';
            document.getElementById('currentCost').textContent = cost ? parseFloat(cost).toFixed(4) : '0.0000';
        }
        
        function updateTokenDisplay() {
            const slider = document.getElementById('maxTokens');
            const display = document.getElementById('tokenDisplay');
            if (slider && display) {
                display.textContent = slider.value;
            }
        }
        
        async function cancelStream() {
            if (currentStreamId && eventSource) {
                try {
                    await fetch(`${API_CONFIG.baseURL}/chat/stream/cancel`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            ...getUserHeaders()
                        },
                        body: JSON.stringify({ stream_id: currentStreamId })
                    });
                } catch (e) {
                    console.warn('Stream cancel failed:', e);
                }
                cleanupStream();
            }
        }

        // Usage tracking functions
        async function loadUserUsage() {
            const indicator = document.getElementById('usageIndicator');
            const usageText = document.getElementById('usageText');
            const usageCount = document.getElementById('usageCount');
            const usageFill = document.getElementById('usageFill');
            const usageDetail = document.getElementById('usageDetail');
            
            if (!indicator) return;
            
            try {
                const userAddress = getUserAddress();
                const response = await fetch(`${API_CONFIG.baseURL}/leaderboard/me/summary?address=${userAddress}`);
                
                if (response.ok) {
                    const data = await response.json();
                    updateUsageDisplay(data);
                    indicator.style.display = 'block';
                } else if (response.status === 404) {
                    // New user - show free tier
                    updateUsageDisplay({
                        free_requests_remaining: 5,
                        free_requests_total: 5,
                        balance: 0,
                        is_new_user: true
                    });
                    indicator.style.display = 'block';
                } else {
                    console.warn('Failed to load user usage:', response.status);
                }
            } catch (error) {
                console.error('Error loading user usage:', error);
                // Don't show indicator if we can't load data
            }
        }
        
        function updateUsageDisplay(data) {
            const indicator = document.getElementById('usageIndicator');
            const usageText = document.getElementById('usageText');
            const usageCount = document.getElementById('usageCount');
            const usageFill = document.getElementById('usageFill');
            const usageDetail = document.getElementById('usageDetail');
            
            if (!indicator) return;
            
            const freeRemaining = data.free_requests_remaining || 0;
            const freeTotal = data.free_requests_total || 5;
            const balance = parseFloat(data.balance || 0);
            const isNewUser = data.is_new_user || false;
            
            // Reset classes
            indicator.className = 'usage-indicator';
            usageFill.className = 'usage-fill';
            
            if (freeRemaining > 0) {
                // Free tier user with remaining requests
                indicator.classList.add('free-tier');
                usageText.textContent = isNewUser ? 'üéÅ Welcome! Free requests' : 'üÜì Free tier';
                usageCount.textContent = `${freeRemaining}/${freeTotal}`;
                
                const percentage = (freeRemaining / freeTotal) * 100;
                usageFill.style.width = `${percentage}%`;
                
                if (percentage <= 20) {
                    usageFill.classList.add('critical');
                    usageDetail.textContent = '‚ö†Ô∏è Almost out of free requests. Consider adding BLY tokens.';
                } else if (percentage <= 50) {
                    usageFill.classList.add('low');
                    usageDetail.textContent = `${freeRemaining} free chats remaining this cycle.`;
                } else {
                    usageDetail.textContent = `${freeRemaining} free chats remaining this cycle.`;
                }
                
            } else if (balance > 0) {
                // Paid user with BLY balance
                indicator.classList.add('paid-tier');
                usageText.textContent = 'üí∞ BLY Balance';
                usageCount.textContent = `${balance.toFixed(4)} BLY`;
                
                // Estimate chat capacity based on average cost (~0.0010 BLY per chat)
                const avgChatCost = 0.0010;
                const estimatedChats = Math.floor(balance / avgChatCost);
                
                if (balance < 0.010) {
                    indicator.classList.remove('paid-tier');
                    indicator.classList.add('low-balance');
                    usageFill.classList.add('critical');
                    usageFill.style.width = '15%';
                    usageDetail.textContent = '‚ö†Ô∏è Low balance! Add more BLY tokens to continue chatting.';
                } else if (balance < 0.050) {
                    usageFill.classList.add('low');
                    usageFill.style.width = '40%';
                    usageDetail.textContent = `~${estimatedChats} chats remaining (avg cost: ${avgChatCost.toFixed(4)} BLY).`;
                } else {
                    usageFill.style.width = '100%';
                    usageDetail.textContent = `~${estimatedChats} chats available (avg cost: ${avgChatCost.toFixed(4)} BLY).`;
                }
                
            } else {
                // No free requests and no balance
                indicator.classList.add('low-balance');
                usageText.textContent = '‚ùå No credits';
                usageCount.textContent = '0 remaining';
                usageFill.classList.add('critical');
                usageFill.style.width = '0%';
                usageDetail.textContent = 'üí° Add BLY tokens or contribute computing power to earn free requests.';
            }
        }
        
        function updateUsageAfterChat(cost) {
            // Update usage display after a chat is sent
            setTimeout(() => {
                loadUserUsage();
                updateHeaderUsage();
            }, 1000); // Reload after 1 second
        }
        
        // Global function to update header usage indicator
        async function updateHeaderUsage() {
            const headerIndicator = document.getElementById('header-usage-indicator');
            const headerText = document.getElementById('header-usage-text');
            
            if (!headerIndicator || !headerText) return;
            
            try {
                const userAddress = getUserAddress();
                const response = await fetch(`${API_CONFIG.baseURL}/leaderboard/me/summary?address=${userAddress}`);
                
                let data;
                if (response.ok) {
                    data = await response.json();
                } else if (response.status === 404) {
                    // New user
                    data = { free_requests_remaining: 5, balance: 0, is_new_user: true };
                } else {
                    return; // Don't show on error
                }
                
                const freeRemaining = data.free_requests_remaining || 0;
                const balance = parseFloat(data.balance || 0);
                
                // Reset classes
                headerIndicator.className = 'header-usage-badge';
                
                if (freeRemaining > 0) {
                    headerIndicator.classList.add('free-tier');
                    headerText.textContent = `üÜì ${freeRemaining} free`;
                } else if (balance > 0) {
                    if (balance < 0.010) {
                        headerIndicator.classList.add('low-balance');
                        headerText.textContent = `‚ö†Ô∏è ${balance.toFixed(4)} BLY`;
                    } else {
                        headerIndicator.classList.add('paid-tier');
                        headerText.textContent = `üí∞ ${balance.toFixed(4)} BLY`;
                    }
                } else {
                    headerIndicator.classList.add('low-balance');
                    headerText.textContent = '‚ùå No credits';
                }
                
                headerIndicator.style.display = 'block';
                
            } catch (error) {
                console.error('Error updating header usage:', error);
            }
        }
        
        // Make function globally available
        window.updateHeaderUsage = updateHeaderUsage;

        // Auto-generate user address for demo
        if (!localStorage.getItem('userAddress')) {
            localStorage.setItem('userAddress', '0x' + Math.random().toString(16).substr(2, 40));
        }
    </script>
</body>
</html>